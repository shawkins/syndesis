/*
 * Copyright (C) 2016 Red Hat, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.syndesis.dv.lsp.parser;

import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

import org.teiid.query.parser.SQLParserConstants;

public final class DdlAnalyzerConstants {

    public enum STATEMENT_TYPE {
        UNKNOWN_STATEMENT_TYPE,
        CREATE_TABLE_TYPE,
        CREATE_FOREIGN_TABLE_TYPE,
        CREATE_FOREIGN_TEMPORARY_TABLE_TYPE,
        CREATE_GLOBAL_TEMPORARY_TABLE_TYPE,
        CREATE_VIEW_TYPE,
        CREATE_VIRTUAL_VIEW_TYPE
    }

    public enum CONTEXT {
        NONE_FOUND,
        PREFIX,
        TABLE_BODY,
        TABLE_OPTIONS,
        TABLE_ELEMENT,
        TABLE_ELEMENT_OPTIONS,
        TABLE_ELEMENT_OPTION_SEARCHABLE,
        QUERY_EXPRESSION,
//        AS_TOKEN,
        SELECT_CLAUSE,
        FROM_CLAUSE,
        WHERE_CLAUSE
    }

    public static final Set<Integer> DATATYPES = Collections.unmodifiableSet(
        new HashSet<>(
            Arrays.asList(
                SQLParserConstants.STRING,
                SQLParserConstants.VARBINARY,
                SQLParserConstants.VARCHAR,
                SQLParserConstants.BOOLEAN,
                SQLParserConstants.BYTE,
                SQLParserConstants.TINYINT,
                SQLParserConstants.SHORT,
                SQLParserConstants.SMALLINT,
                SQLParserConstants.CHAR,
                SQLParserConstants.INTEGER,
                SQLParserConstants.LONG,
                SQLParserConstants.BIGINT,
                SQLParserConstants.BIGINTEGER,
                SQLParserConstants.FLOAT,
                SQLParserConstants.REAL,
                SQLParserConstants.DOUBLE,
                SQLParserConstants.BIGDECIMAL,
                SQLParserConstants.DECIMAL,
                SQLParserConstants.DATE,
                SQLParserConstants.TIME,
                SQLParserConstants.TIMESTAMP,
                SQLParserConstants.BLOB,
                SQLParserConstants.CLOB,
                SQLParserConstants.XML,
                SQLParserConstants.JSON,
                SQLParserConstants.GEOMETRY,
                SQLParserConstants.GEOGRAPHY,
                SQLParserConstants.OBJECT
            )));

    static final String[] DATATYPE_LIST = {
        getLabel(SQLParserConstants.STRING, false),
        getLabel(SQLParserConstants.VARBINARY, false),
        getLabel(SQLParserConstants.VARCHAR, false),
        getLabel(SQLParserConstants.BOOLEAN, false),
        getLabel(SQLParserConstants.BYTE, false),
        getLabel(SQLParserConstants.TINYINT, false),
        getLabel(SQLParserConstants.SHORT, false),
        getLabel(SQLParserConstants.SMALLINT, false),
        getLabel(SQLParserConstants.CHAR, false),
        getLabel(SQLParserConstants.INTEGER, false),
        getLabel(SQLParserConstants.LONG, false),
        getLabel(SQLParserConstants.BIGINT, false),
        getLabel(SQLParserConstants.BIGINTEGER, false),
        getLabel(SQLParserConstants.FLOAT, false),
        getLabel(SQLParserConstants.REAL, false),
        getLabel(SQLParserConstants.DOUBLE, false),
        getLabel(SQLParserConstants.BIGDECIMAL, false),
        getLabel(SQLParserConstants.DECIMAL, false),
        getLabel(SQLParserConstants.DATE, false),
        getLabel(SQLParserConstants.TIME, false),
        getLabel(SQLParserConstants.TIMESTAMP, false),
        getLabel(SQLParserConstants.BLOB, false),
        getLabel(SQLParserConstants.CLOB, false),
        getLabel(SQLParserConstants.XML, false),
        getLabel(SQLParserConstants.JSON, false),
        getLabel(SQLParserConstants.GEOMETRY, false),
        getLabel(SQLParserConstants.GEOGRAPHY, false),
        getLabel(SQLParserConstants.OBJECT, false)
    };

    /*
     * Array of tokens that match the start of a CREATE TABLE statement
     */
    static final int[] CREATE_TABLE_STATEMENT = { SQLParserConstants.CREATE, SQLParserConstants.TABLE };

    /*
     * Array of tokens that match the start of a CREATE FOREIGNT TABLE statement
     */
    static final int[] CREATE_FOREIGN_TABLE_STATEMENT = { SQLParserConstants.CREATE, SQLParserConstants.FOREIGN, SQLParserConstants.TABLE };

    /*
     * Array of tokens that match the start of a CREATE FOREIGN TEMPORARY TABLE
     * statement
     */
    static final int[] CREATE_FOREIGN_TEMPORARY_TABLE_STATEMENT = { SQLParserConstants.CREATE, SQLParserConstants.FOREIGN, SQLParserConstants.TEMPORARY, SQLParserConstants.TABLE };

    /*
     * Array of tokens that match the start of a CREATE TEMPORARY TABLE
     * statement
     */
    static final int[] CREATE_GLOBAL_TEMPORARY_TABLE_STATEMENT = { SQLParserConstants.CREATE, SQLParserConstants.GLOBAL, SQLParserConstants.TEMPORARY, SQLParserConstants.TABLE };

    /*
     * Array of tokens that match the start of a CREATE VIEW
     * statement
     */
    static final int[] CREATE_VIEW_STATEMENT = { SQLParserConstants.CREATE, SQLParserConstants.VIEW };

    /*
     * Array of tokens that match the start of a CREATE VIRTUAL VIEW
     * statement
     */
    static final int[] CREATE_VIRTUAL_VIEW_STATEMENT = { SQLParserConstants.CREATE, SQLParserConstants.VIRTUAL, SQLParserConstants.VIEW };

    int[] NON_DATATYPE_KEYWORDS = {
            ACCESS,
            ADD,
            AFTER,
            ALL,
            ALLOCATE,
            ALTER,
            ANALYZE,
            AND,
            ANY,
            ARE,
            ARRAY,
            ARRAY_AGG,
            ARRAYTABLE,
            AS,
            ASC,
            ASENSITIVE,
            ASYMETRIC,
            ATOMIC,
            AUTHENTICATED,
            //AUTHORIZATION,
            AUTO_INCREMENT,
            AVG,
            BEGIN,
            BETWEEN,
            BINARY,
            BOTH,
            BREAK,
            BY,
            CALL,
            CALLED,
            CASCADED,
            CASE,
            CAST,
            CHAIN,
            CHECK,
            CLOSE,
            COLLATE,
            COLUMN,
            COLUMNS,
            COMMIT,
            CONDITION,
            CONNECT,
            CONSTRAINT,
            CONTENT,
            CONTINUE,
            CONTROL,
            CONVERT,
            CORRESPONDING,
            COUNT,
            COUNT_BIG,
            CREATE,
            CRITERIA,
            CROSS,
            CUME_DIST,
            CURRENT,
            CURRENT_DATE,
            CURRENT_TIME,
            CURRENT_TIMESTAMP,
            CURRENT_USER,
            CURSOR,
            CYCLE,
            DATA,
            DATABASE,
            DATALINK,
            DAY,
            DEALLOCATE,
            DEC,
            DECLARE,
            DEFAULT,
            DELETE,
            DELIMITER,
            DENSE_RANK,
            DEREF,
            DESC,
            DESCRIBE,
            DETERMINISTIC,
            DISABLED,
            DISCONNECT,
            DISTINCT,
            DLNEWCOPY,
            DLPREVIOUSCOPY,
            //DLURELCOMPLETEWRITE,
            DLURLCOMPLETE,
            DLURLCOMPLETEONLY,
            DLURLPATH,
            DLURLPATHONLY,
            DLURLPATHWRITE,
            DLURLSCHEME,
            //DLURLSEVER,
            DLVALUE,
            DOCUMENT,
            DOMAIN,
            DOUBLE,
            DROP,
            DYNAMIC,
            EACH,
            ELEMENT,
            ELSE,
            EMPTY,
            ENABLED,
            ENCODING,
            END,
            ERROR,
            ESCAPE,
            EVERY,
            EXCEPT,
            EXCLUDING,
            EXEC,
            EXECUTE,
            EXISTS,
            EXPLAIN,
            EXTERNAL,
            FALSE,
            FETCH,
            FILTER,
            FIRST,
            FOLLOWING,
            FOR,
            FOREIGN,
            FORMAT,
            FREE,
            FROM,
            FULL,
            FUNCTION,
            GET,
            GLOBAL,
            GRANT,
            GROUP,
            //GROUPING,
            HANDLER,
            HAS,
            HAVING,
            HEADER,
            HOLD,
            HOUR,
            IDENTITY,
            IF,
            IMMEDIATE,
            IMPORT,
            IN,
            INCLUDING,
            INDEX,
            INDICATOR,
            INNER,
            INOUT,
            INPUT,
            INSENSITIVE,
            INSERT,
            INSTEAD,
            INTERSECT,
            INTERVAL,
            INTO,
            IS,
            ISOLATION,
            JAAS,
            JOIN,
            JSONARRAY_AGG,
            JSONOBJECT,
            JSONTABLE,
            KEY,
            LANGUAGE,
            LARGE,
            LAST,
            LATERAL,
            LEADING,
            LEAVE,
            LEFT,
            LIKE,
            LIKE_REGEX,
            LIMIT,
            LISTAGG,
            LOCAL,
            LOCALTIME,
            LOOP,
            MAKEDEP,
            MAKEIND,
            MAKENOTDEP,
            MASK,
            MATCH,
            MAX,
            MEMBER,
            MERGE,
            METHOD,
            MIN,
            MINUTE,
            MODIFIES,
            MODULE,
            MONTH,
            MULTISET,
            NATIONAL,
            NATURAL,
            NCHAR,
            NCLOB,
            NEW,
            NO,
            NOCACHE,
            NONE,
            NOT,
            NULL,
            NULLS,
            NUMERIC,
            OBJECTTABLE,
            OF,
            OFFSET,
            OLD,
            ON,
            ONLY,
            OPEN,
            OPTION,
            OPTIONS,
            OR,
            ORDER,
            ORDINALITY,
            OUT,
            OUTER,
            OUTPUT,
            OVER,
            OVERLAPS,
            PARAMETER,
            PARTITION,
            PASSING,
            PATH,
            PERCENT_RANK,
            POSITION,
            PRECEDING,
            PRECISION,
            PREPARE,
            PRESERVE,
            PRIMARY,
            PRIVILEGES,
            PROCEDURE,
            QUERYSTRING,
            QUOTE,
            RAISE,
            RANGE,
            RANK,
            READS,
            RECURSIVE,
            REFERENCES,
            REFERENCING,
            RELEASE,
            RENAME,
            REPOSITORY,
            RESULT,
            RETURN,
            //RETURNING,
            RETURNS,
            REVOKE,
            RIGHT,
            ROLE,
            ROLLBACK,
            ROLLUP,
            ROW,
            ROW_NUMBER,
            ROWS,
            SAVEPOINT,
            SCHEMA,
            SCROLL,
            SEARCH,
            SECOND,
            SELECT,
            SELECTOR,
            SENSITIVE,
            //SEQUENCE,
            SERIAL,
            SERVER,
            SESSION_USER,
            SET,
            SIMILAR,
            //SKIP,
            SOME,
            SPECIFIC,
            SPECIFICTYPE,
            SQL,
            SQL_TSI_DAY,
            SQL_TSI_FRAC_SECOND,
            SQL_TSI_HOUR,
            SQL_TSI_MINUTE,
            SQL_TSI_MONTH,
            SQL_TSI_QUARTER,
            SQL_TSI_SECOND,
            SQL_TSI_WEEK,
            SQL_TSI_YEAR,
            SQLEXCEPTION,
            SQLSTATE,
            SQLWARNING,
            START,
            STATIC,
            STDDEV_POP,
            STDDEV_SAMP,
            SUBMULTILIST,
            SUM,
            SYMETRIC,
            SYSTEM,
            SYSTEM_USER,
            TABLE,
            TEMPORARY,
            TEXT,
            TEXTAGG,
            THEN,
            TIMESTAMPADD,
            TIMESTAMPDIFF,
            TIMEZONE_HOUR,
            TIMEZONE_MINUTE,
            TO,
            TRAILING,
            TRANSLATE,
            TRANSLATION,
            TRANSLATOR,
            TREAT,
            TRIGGER,
            TRIM,
            TRUE,
            TYPE,
            UNBOUNDED,
            UNION,
            UNIQUE,
            UNKNOWN,
            UPDATE,
            UPSERT,
            USAGE,
            USE,
            USER,
            USING,
            VALUE,
            VALUES,
            VAR_POP,
            VAR_SAMP,
            VARIADIC,
            VARYING,
            VERSION,
            VIEW,
            VIRTUAL,
            WELLFORMED,
            WHEN,
            WHENEVER,
            WHERE,
            WHILE,
            WIDTH,
            WINDOW,
            WITH,
            WITHIN,
            WITHOUT,
            WRAPPER,
            XMLAGG,
            XMLATTRIBUTES,
            XMLBINARY,
            XMLCAST,
            XMLCOMMENT,
            XMLCONCAT,
            XMLDECLARATION,
            XMLDOCUMENT,
            XMLELEMENT,
            XMLEXISTS,
            XMLFOREST,
            XMLITERATE,
            XMLNAMESPACES,
            XMLPARSE,
            XMLPI,
            XMLQUERY,
            XMLSERIALIZE,
            XMLTABLE,
            XMLTEXT,
            XMLVALIDATE,
            YAML,
            YEAR
    };

    int[] COLUMN_DEFINITION_EXTRAS = {
            AUTO_INCREMENT,
            DEFAULT_KEYWORD,
            NOT,
            NULL,
            PRIMARY,
            KEY,
            INDEX,
            UNIQUE
    };

    /*
     * The getLabel(...] call is returning strings wrapped in double-quotes
     *
     * Need to return a simple string
     * @param tokenImageString string
     * @return string without double quotes
     */
    public static String getLabel(int keywordId, boolean upperCase) {
         String tokenImageStr = SQLParserConstants.tokenImage[keywordId];
         if( upperCase ) {
             return tokenImageStr.substring(1, tokenImageStr.length()-1).toUpperCase();
         }
         return tokenImageStr.substring(1, tokenImageStr.length()-1);
     }
}
